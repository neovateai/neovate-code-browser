import type { Element } from 'hast';
import type { ShikiTransformer } from 'shiki';

// Type definitions for line metadata
interface LineMetadata {
  type: 'add' | 'remove' | null;
}

// Constants for diff markers
export const DIFF_MARKERS = {
  ADD: '// [!code ++]',
  REMOVE: '// [!code --]',
} as const;

/**
 * Creates a custom Shiki transformer for handling diff notation markers.
 *
 * This transformer processes VitePress-style diff markers in code:
 * - `// [!code ++]` for added lines (green background)
 * - `// [!code --]` for removed lines (red background)
 *
 * The transformer adds appropriate CSS classes and removes the marker text
 * from the final rendered output.
 *
 * @returns A Shiki transformer object
 */
export const customDiffTransformer = (): ShikiTransformer => {
  // Store line metadata for later use
  const lineMetadata: Map<number, LineMetadata> = new Map();

  return {
    name: 'custom-diff-transformer',

    /**
     * Preprocesses the code before syntax highlighting.
     *
     * This runs before Shiki parses the code, allowing us to:
     * 1. Detect diff markers in raw text
     * 2. Store metadata about which lines are add/remove
     * 3. Remove markers before they get syntax highlighted
     *
     * This prevents markers from being split across multiple spans.
     */
    preprocess(code: string) {
      const lines = code.split('\n');
      const processedLines = lines.map((line, index) => {
        const lineNumber = index + 1;

        if (line.includes(DIFF_MARKERS.ADD)) {
          lineMetadata.set(lineNumber, { type: 'add' });
          return line.replace(DIFF_MARKERS.ADD, '').trimEnd();
        }

        if (line.includes(DIFF_MARKERS.REMOVE)) {
          lineMetadata.set(lineNumber, { type: 'remove' });
          return line.replace(DIFF_MARKERS.REMOVE, '').trimEnd();
        }

        lineMetadata.set(lineNumber, { type: null });
        return line;
      });

      return processedLines.join('\n');
    },

    /**
     * Processes each line of code in the AST.
     *
     * Uses the metadata collected during preprocessing to:
     * 1. Add appropriate CSS classes for styling
     * 2. No need to remove markers (already done in preprocess)
     *
     * @param node - The AST Element node representing a line of code
     * @param lineNumber - The current line number (1-based)
     */
    line(node: Element, lineNumber: number) {
      try {
        const metadata = lineMetadata.get(lineNumber);
        if (!metadata || !metadata.type) return;

        // Add CSS classes based on metadata
        if (metadata.type === 'add') {
          addCSSClass(node, 'diff add');
        } else if (metadata.type === 'remove') {
          addCSSClass(node, 'diff remove');
        }
      } catch (error) {
        // Log error for debugging, but don't break rendering
        console.warn('Diff transformer error at line', lineNumber, ':', error);
      }
    },

    /**
     * Final cleanup pass on the generated HTML.
     *
     * Since markers are removed in preprocess, this should not be needed.
     * Kept as a safety net for any edge cases.
     *
     * @param html - The complete HTML string generated by Shiki
     * @returns HTML string (should already be clean)
     */
    postprocess(html: string) {
      // Safety net: remove any remaining markers (should be rare)
      return html.replace(/\/\/\s*\[!code\s*[+\-]{2}\]\s*/g, '');
    },
  };
};

/**
 * Adds a CSS class to an AST Element node's properties.
 *
 * This function safely adds CSS classes to a node, preserving any
 * existing classes and ensuring the properties object exists.
 *
 * @param node - AST Element node to modify
 * @param className - CSS class name to add (e.g., 'diff add', 'diff remove')
 */
function addCSSClass(node: Element, className: string): void {
  // Ensure properties object exists
  node.properties = node.properties || {};

  // Get current class value and normalize to string
  const currentClass = node.properties.class;
  const existingClasses = currentClass ? String(currentClass) : '';

  // Add new class and clean up whitespace
  node.properties.class = `${existingClasses} ${className}`.trim();
}
